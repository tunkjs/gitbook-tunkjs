{"./":{"url":"./","title":"学习笔记","keywords":"","body":" 学习笔记 var className='toc';"},"doc/base/基本概念.html":{"url":"doc/base/基本概念.html","title":"基本概念","keywords":"","body":"tunk基本概念 Store State Module(模块) Action Store 存储状态树数据，提供tunk内部读取和更新状态树数据的方法。 tunk默认使用的是内置的Store对象，你也可以使用自定义的Store对象来改变数据存储、读取方式 对常规业务开发是透明的，仅在扩展组件的开发中暴露store相关接口 开发自定义Store对象 State 读取自store的状态快照，修改state将不会影响到store存储的数据 在constructor内赋给this.state的对象字段作为定义该模块的状态字段，后续的状态维护将不会再创建新状态字段， 模块内部可通过this.state和this.getState()读取当前模块的state，向this.getState()传入参数，也可获得其他模块的state 使用tunk-vue 或 tunk-react的时候，state也会被注入到订阅了特定模块的state的视图组件 Module(模块) 负责定义初始化状态数据及维护这些数据的Action集合，是一个Store数据树子集数据的处理类的实例化对象。 通过@create或tunk.createModule()创建并实例化 constructor内定义的this.state的对象作为Store内同类名节点的初始数据 一个模块负责管理Store数据树的一个子集 Action 模块类中使用@action修饰的方法，唯一可触发Store状态变化的方式。 Action通过return返回的数据和dispatch方法传入的数据都会先经过 中间件 的处理，最后可能会触发State的变化 支持异步Action，避免过多函数嵌套 @action async fetchList(page, page_size){ const res = await this.request ... return {list: res.list, totalCount: res.total_count} } Action内调其他Action @action addUser(gender, name, age){ //调起当前模块的其他Action跟调普通方法无异 this.fetchList(page, page_size); this.dispatch('fetchList', page, page_size); this.dispatch('userAdmin.fetchList', page, page_size); //调起其他模块的Action this.dispatch('moduleName.actionName', [param1, param2, ...]); } 在异步Action调起其他Action，可获得被调用Action return返回的结果，此时，store已经完成状态的更新 //异步Action @action async deleteUser(){ //可获得Action执行return的结果 const result1 = await this.fetchList(page, page_size); const result2 = await this.dispatch('fetchList', page, page_size); const result3 = await this.dispatch('userAdmin.fetchList', page, page_size); //调起其他模块的Action const result4 = await this.dispatch('moduleName.actionName', [param1, param2, ...]); } var className='toc';"},"doc/base/数据流.html":{"url":"doc/base/数据流.html","title":"数据流","keywords":"","body":" 视图层触发交互事件 交互事件回调发起Action执行 执行Action Action返回的结果或dispatch的数据，进入中间件处理流程 满足一定条件进入到内置store中间件后，调起setStore钩子 setStore钩子执行Store对象提供的方法 store.setState 将定义为状态的字段数据存储到store，并返回action执行返回的所有数据 让视图框架跟tunk一起工作的组件（如tunk-vue）切入setStore钩子获得状态更新的通知 在切入setStore钩子的回调，获取到新状态并找到绑定了新状态相关字段的视图组件，将新状态数据逐一注入其中 var className='toc';"},"doc/base/tunk-api.html":{"url":"doc/base/tunk-api.html","title":"tunk API","keywords":"","body":"tunk API @create @action Create Action use config @create @create([moduleName:String, options:Object]) create修饰器，用于重构模块类及生成模块实例 moduleName：由于UgligyJS会将类名压缩，因此没使用tunk-loader的话需要传入需要创建的模块名 options：为模块级别的配置，将覆盖全局配置中同名字段的配置 如仅查看某个action的相关debug log: tunk.config({debug:false}); // 在特定的模块create修饰器传入即可 @create({debug: true}) class someModule{ ... } @action @action([options:Object]) action修饰器，用于定义一个方法为一个Action options：为action级别的配置，将覆盖模块配置中同名字段的配置 跟全局配置与模块配置的关系，相当于 Object.assign(globalConfig, moduleConfig, actionConfig) 如仅查看某个action的相关debug log: @action({debug: true}) Create tunk.Create(moduleName:String, module:Object, [options:Object]) 若语法环境不支持修饰器的写法，tunk还提供了ES5写法 moduleName：模块名 module：模块对象，对象必须有constructor方法 options：模块配置，同@create(options) 作用一致 tunk.Create('userAdmin', { constructor: function userAdmin(){ this.state = { list:[] }; } }, {debug:true}); Action tunk.Action(target:Function, [options:Object]) 跟tunk.Create配合使用，定义一个方法为Action target：需要被定义为Action的函数 options：action级别的配置，同@action(options) 作用一致 tunk.Create('userAdmin', { constructor: function userAdmin(){ this.state = { list:[] }; }, fetchList: tunk.Action(function(){ ... }, {debug: true}), }); use tunk.use(plugins:Array) 使用tunk组件，了解tunk组件开发，可戳这里 tunk组件开发 import tunk from \"tunk\"; import tunkVue from \"tunk-vue\"; import tunkDebug from \"tunk-debug\"; tunk.use([tunkVue, tunkDebug]); config tunk.config(configs:Object) tunk全局配置 // debug配置由debug组件提供支持，设为true可查看全局相关debug log tunk.config({debug:true}); var className='toc';"},"doc/base/module-api.html":{"url":"doc/base/module-api.html","title":"module API","keywords":"","body":"module API state getState dispatch mixin methods state 在constructor内可同步设置初始状态数据 初始化之后为只读属性，读取当前模块所维护的状态，二次赋值将报错 this.state实际不存储状态，读取的数据都来自store字段名为模块名的节点 getState this.getState([statePath:string]) this.getState() 不传参数读取的是当前模块的状态 this.getState('userAdmin') 获取模块名为'userAdmin'的模块负责维护的所有状态 this.getState('userAdmin.list') 获取模块名为'userAdmin'的模块字段名为'list'的状态 this.getState('userAdmin.list.0.id') 获取模块名为'userAdmin'的模块字段名为'list'的数据是一个数组，那么将读取这个数组第一个元素的id 这种对象深度读取的方式由tunk内置的Store对象提供，最多可读取深度为5的数据 dispatch this.dispatch([arg1, arg2, arg3...]) dispatch分发数据到中间件，的功能由中间件提供 tunk有两个内置中间件：调起action中间件，保存状态中间件 调起action中间件： this.dispatch(actionPath:String, [arg1, arg2...]) actionPath：由模块名和action名组成，如：'userAdmin.fetchList'，也可直接写，如果是当前模块的action，可直接写action名如：‘fetchList’。 args：支持向fetchList传入多个参数 状态保存中间件： this.dispatch(newState:Object) newState 如果判断到传入的是一个参数且为Object类型，将会通过该中间件保存到store中 关于tunk中间件的作用及如何开发业务中间件 mixin methods 由组件提供的模块通用内置方法，如何添加mixin方法，请查看 tunk组件开发 var className='toc';"},"doc/plugins/tunk-react.html":{"url":"doc/plugins/tunk-react.html","title":"tunk-react","keywords":"","body":"tunk-react tunk-react定义了react与tunk配合工作的方式： 触发Action 及 将新状态注入视图组件 安装 npm install tunk-react -S 引入 import tunk from 'tunk'; import tunkReact from 'tunk-react'; tunk.use([tunkReact, tunkDebug]); // 引入状态管理模块即可完成状态管理模块的初始化 //require('./userAdmin'); // 也可批量引入（通常我们都把模块js放到统一目录下，如：modules） var modules = require.context('./modules', true, /\\.js$/); modules.keys().forEach((item) => { modules(item); }); A. 如何调起模块的Action import { connect } from 'tunk-react' @connect({}, {// 代理action设置 // 创建getDetails方法可调起模块的getUserDetails getDetails: 'userAdmin.getUserDetails' // 若设置为 userAdmin: 'userAdmin' // 则将所有方法注入到userAdmin属性 // 通过 this.userAdmin.getUserDetails(...) 调用 }) export default class UserAdmin extends Component { constructor() { // 1、通过dispatch方式调起action this.dispatch('userAdmin.fetchList'); } async showUserDetails(id) { // 2、调用action代理方法 this.getDetails(id).details; } render() { const { list } = this.props; return ( {list.map(item => ( ... 查看用户信息 ))} ) } } 两种方式调起action 通过在connect设置action注入配置，向视图组件注入Action代理方法 使用tunk-react提供的 this.dispatch('moduleName.actionName', [arg1, arg2, ...])，支持返回action内执行return的内容，支持Promise B. 视图组件获得新状态 import { connect } from 'tunk-react' @connect({ // 1、状态订阅配置 // list 是模块userAdmin定义的状态字段，可以被视图组件订阅 // 组件被初始化后this.list将被作为prop注入当前 userAdmin.list 的状态 // 注入前触发 componentWillReceiveProps list: 'userAdmin.list' }) export default class UserAdmin extends Component { constructor() { // 通过dispatch方式调起action // action返回状态字段数据更新store状态树状态，从而注入到当前组件 this.dispatch('userAdmin.fetchList'); } async showUserDetails(id) { // 2、调用action代理方法，并获得action执行结果 const details = await this.getDetails(id).details; // 也可以通过dispatch调起action获得action执行结果 // const details = await this.dispatch('userAdmin.getUserDetails', id).details; } render() { // 以prop的方式注入到当前组件 const { list } = this.props; return ( {list.map(item => ( ... 查看用户信息 ))} ) } } 两种方式获得新状态 被动注入：通过给组件添加订阅状态属性state，设置要订阅的模块状态字段路径，该视图组件将会被动态注入相关的状态数据 主动获取：tunk-vue为vue组件提供的 dispatch方法，可获得action方法return的内容 更多tunk实例 github var className='toc';"},"doc/plugins/tunk-vue.html":{"url":"doc/plugins/tunk-vue.html","title":"tunk-vue","keywords":"","body":"tunk-vue tunk-vue 顾名思义，是让tunk与vue可以一起工作的组件，负责定义视图层如何 触发Action 及如何 将新状态注入到视图组件。 安装 npm install tunk-vue -S 引入 import tunk from 'tunk' import tunkVue from 'tunk-vue' tunk.use([tunkVue]); // 引入状态管理模块即可完成状态管理模块的初始化 //require('./userAdmin'); // 也可批量引入（通常我们都把模块js放到统一目录下，如：modules） var modules = require.context('./modules', true, /\\.js$/); modules.keys().forEach((item) => { modules(item); }); A. 两种方式触发模块的Action 通过添加actions属性向视图组件注入Action代理方法 使用tunk-vue提供的 this.dispatch('moduleName.actionName', [arg1, arg2, ...])，支持返回action内执行return的内容，支持Promise 注意： $dispatch是vue内置的方法，不带 $ 的是tunk-vue提供的方法 ... 查看用户信息 ... export default { actions: { // 设置actions，注入action代理方法 getDetails: 'userAdmin.getUserDetails', // 若设置为 userAdmin: 'userAdmin' // 则将所有方法注入到userAdmin属性 // 通过 this.userAdmin.getUserDetails(...) 调用 }, created() { // 通过dispatch方式调起action this.dispatch('userAdmin.fetchList'); }, methods:{ async showUserDetails(id){ // 调用action代理方法 const details = await this.getDetails(id).details; } } } 通过state设置订阅的状态变更，会先触发 beforeStState 钩子，并传入新状态变更 用户可通过beforeStState控制新状态通过setData注入当前组件，beforeStState中return返回的对象将会代替newState注入到组件中 如用户未定义beforeStState或beforeStState未返回Object结果，将直接将新状态注入到组件 B. 两种方式获得Action处理结果 被动注入：通过给组件添加订阅状态属性state，设置要订阅的模块状态字段路径，该视图组件将会被动态注入相关的状态数据 主动获取：tunk-vue为vue组件提供的 dispatch方法，可获得action方法return的内容 ... 查看用户信息 ... export default { // 状态订阅配置 state: { // list 是userAdmin定义的状态字段 // 组件被初始化后this.list将被注入当前 userAdmin.list 的状态 list: 'userAdmin.list' }, created() { this.dispatch('userAdmin.fetchList'); } methods: { async showUserDetails(id) { // 主动获取用户详情 const details = await this.dispatch('userAdmin.getUserDetails', id).details; ... } } } 更多tunk实例 github var className='toc';"},"doc/plugins/tunk-wechat.html":{"url":"doc/plugins/tunk-wechat.html","title":"tunk-wechat","keywords":"","body":"tunk-wechat tunk-wechat使tunk支持微信小程序，负责定义视图层如何 触发Action 及如何 将新状态注入到视图组件。 微信小程序整体代码风格跟vue有几分相似，我们可以将小程序提供的js-wxml-wxss代码结构看作一个视图组件，tunk担当数据服务层，tunk与微信小程序完美合体！ tunk灵活的通信机制可以有效避开状态管理的性能问题，为了提高tunk与小程序协作能力，我们也做了有针对性的优化。譬如，隐藏的页面不会被注入新状态，提供onBeforeStateChange钩子控制如何setData 安装 npm install tunk-wechat -S 引入 import tunk from 'tunk' import tunkWechat, {App} from 'tunk-wechat' tunk.use([tunkWechat]); // 引入放在modules文件夹下面的countdown模块 require('modules/countdown'); App({ onLaunch: function () {} } API tunk-wechat内部封装了全局App、Page构建方法，同时提供同名的构建方法，使用方式也与小程序提供的App、Page一致 import {App, Page} from 'tunk-wechat' App 注册小程序 actions属性 支持actions属性的设置，注入action的代理方法 App({ actions:{ myFunc: 'myModule.myAction' }, onLaunch: function () { // 调用myModule模块的myAction代理方法 this.myFunc(); } } dispatch方法 支持使用dispatch调起模块的action App({ onLaunch: function () { // 调起myModule模块的myAction this.dispatch('myModule.myAction', arg1, arg2...); } } Page 注册页面 Page支持actions设置和dispatch方法，下面不再说明 state设置 Page({ state: { cd: 'countdown.count' } } Page执行后，会给data对象添加相应的字段，如上例的：cd字段，Page onload前或状态变更后，会将'countdown.count'对应状态数据，通过setData注入到cd字段 状态变更不会注入到隐藏的Page，只会记录该Page有哪些订阅的状态发生变更，onShow之后将会从数据服务层获得已订阅的、已变更的最新状态 onBeforeStateChange Page({ state: { cd: 'countdown.count' }, onBeforeStateChange(newState){ return {cd: newState.cd} } } 通过state设置订阅的状态变更，在setData前，会先触发 onBeforeStateChange 钩子，并传入新状态变更 用户可通过onBeforeStateChange控制新状态通过setData注入当前组件，onBeforeStateChange中return返回的对象将会代替newState执行setData注入到组件中 如用户未定义onBeforeStateChange或onBeforeStateChange未返回Object结果，将直接将新状态通过setData注入到组件 不建议把过多的逻辑放到onBeforeStateChange处理 dispatch 用于调起数据服务模块的action，可获得返回action内执行return的内容，支持Promise Page({ onLoad(){ this.dispatch('countdown.increase', arg1, arg2 ...); } } 与tunk数据服务层通信总结 A. 两种方式触发模块的Action 通过添加actions设置向视图组件注入Action代理方法，直接调用这些代理方法 使用tunk-wechat提供的 this.dispatch('moduleName.actionName', [arg1, arg2, ...]) B. 两种方式获得Action处理结果 被动注入：通过给组件添加订阅状态属性state，设置要订阅的模块状态字段路径，该视图组件将会被动态注入相关的状态数据 主动获取：tunk-wechat为小程序App、Page提供的 dispatch方法，可获得action方法return的内容 更多tunk实例 github var className='toc';"},"doc/plugin-dev/概述.html":{"url":"doc/plugin-dev/概述.html","title":"组件开发","keywords":"","body":"待更新... var className='toc';"},"doc/plugin-dev/middleware.html":{"url":"doc/plugin-dev/middleware.html","title":"middleware","keywords":"","body":"待更新... var className='toc';"},"doc/plugin-dev/hooks.html":{"url":"doc/plugin-dev/hooks.html","title":"hooks","keywords":"","body":"待更新... var className='toc';"},"doc/plugin-dev/store.html":{"url":"doc/plugin-dev/store.html","title":"store","keywords":"","body":"待更新... var className='toc';"},"doc/plugin-dev/config.html":{"url":"doc/plugin-dev/config.html","title":"config","keywords":"","body":"var className='toc';"},"doc/plugins/":{"url":"doc/plugins/","title":"组件推荐","keywords":"","body":" var className='toc';"},"doc/plugins/tunk-debug.html":{"url":"doc/plugins/tunk-debug.html","title":"tunk-debug","keywords":"","body":"tunk-debug tunk开发的debug工具，设置了 debug:true 之后的动作执行，在console中会有相应详细信息输出 安装 npm install tunk-debug 引用 import tunkDebug from 'tunk-debug' tunk.use([tunkDebug]); 启用配置 debug:[true | false | Array] default: false // 1、全局配置debug，作用到所有模块和action tunk.config({debug:true}); // 2、针对模块配置，仅作用于该模块，及该模块的所有action @create({debug: true}) class demo { constructor(){ .... } // 3、针对ation配置，仅作用于该action @action({debug:false}) sayHi(){ ... } } 当debug为Array时，元素取值为hooks名，仅打出传入的hooks 本插件会在console打印出所有hooks名 tunk.config({debug: ['setState', 'getState']}); github var className='toc';"},"doc/plugins/tunk-request.html":{"url":"doc/plugins/tunk-request.html","title":"tunk-request","keywords":"","body":"tunk-request ajax请求工具插件，支持promise 安装 npm install tunk-request -S 引用 import tunkRequest from \"tunk-request\"; tunk.use([ tunkRequest({ onBeforeSend: () => {}, onComplite: dataString => (dataString), onSuccess: (res, xhr, setting) => {}, onError: (error, xhr, setting) => {} }) ]); ### Methods ````javascript import {create, action} from 'tunk'; @create export default class app { constructor(){ this.state = { hello: 'tunk-request' }; this.request(Options) // 便捷方法，仅支持 url, data, success, error, dataType 参数，且参数顺序可不固定 // 第一个字符串 视为 url， 第一个function 视为 success this.request.get( url, data, success, error, dataType ) this.request.post( url, data, success, error, dataType ) this.request.getJson( url, data, success, error ) this.request.jsonp( url, data, success, error ) } @action async getData(){ const res = await this.request.get( url, data, success, error, dataType ) return {hello: res.tunk.request} } } Options // Default type of request type: 'GET', // html json script xml text dataType: '', // Callback that is executed before request beforeSend: empty, // Callback that is executed if the request succeeds success: empty, // Callback that is executed the the server drops error error: empty, // Callback that is executed on request complete (both: error and success) complete: empty, // Whether to trigger \"global\" Ajax events global: true, // Transport xhr: function () { return new window.XMLHttpRequest() }, // MIME types mapping // IIS returns Javascript as \"application/x-javascript\" accepts: { script: 'text/javascript, application/javascript, application/x-javascript', json: jsonType, xml: 'application/xml, text/xml', html: htmlType, text: 'text/plain' }, // Whether the request is to another domain crossDomain: false, // Default timeout timeout: 0, // Whether data should be serialized to string processData: true, // Whether the browser should be allowed to cache GET responses cache: true, //Used to handle the raw response data of XMLHttpRequest. //This is a pre-filtering function to sanitize the response. //The sanitized response should be returned dataFilter: empty github var className='toc';"},"doc/plugins/tunk-loader.html":{"url":"doc/plugins/tunk-loader.html","title":"tunk-loader","keywords":"","body":"tunk-loader webpack loader，用于处理使用修饰器时tunk模块被打包压缩时模块类名被压缩的尴尬 安装 npm install tunk-react -S 配置 { test: /\\.js$/, loader: ['babel-loader', 'tunk-loader'], exclude: /(node_modules)/ } github var className='toc';"},"doc/topic/":{"url":"doc/topic/","title":"Topic","keywords":"","body":"var className='toc';"},"doc/topic/tunk性能优化.html":{"url":"doc/topic/tunk性能优化.html","title":"tunk性能优化","keywords":"","body":"var className='toc';"},"doc/topic/使用tunk的一些建议.html":{"url":"doc/topic/使用tunk的一些建议.html","title":"使用tunk的一些建议","keywords":"","body":"var className='toc';"},"doc/topic/选择tunkjs的理由.html":{"url":"doc/topic/选择tunkjs的理由.html","title":"选择tunkjs的理由","keywords":"","body":"引用别人的话：如果你总是想着“状态管理”，觉得自己要解决“状态管理”这个很严肃的问题，你大概就会在错误的道路上越走越远。 状态管理器在项目中实际应用中，很多时候是某些场景下并不需要状态管理，这些场景的代码组织常常显得比较尴尬，不是违背代码组织的一致性，就是不符合状态管理的必要性。 开发完了wap版本，需要再开发微信小程序版本或者嵌入到原生APP的RN版本，如何做到最大化的复用wap版本的代码？ 数据处理逻辑与交互逻辑分离可以很好地解决这个问题。交互逻辑通常直接依赖不同平台的视图实现，而数据处理逻辑可以做到跟交互逻辑完全解耦，数据处理逻辑很大程度上是可以直接复用的。 逐渐深入React+Redux开发一些项目，越发觉得很多成本是花在为了满足框架要求而编码，并不能很好的专注于业务逻辑的开发，既降低了开发效率，也提高了开发维护成本。 视图层之外需要解决的不只是状态管理问题，架构合理性问题、编程体验问题、学习成本问题等是前端工程化需要解决的问题。架构性框架作为工程化核心部分，应该以使用者为中心，简化架构、简化api、简化组件模块通信方式、减轻框架自身的存在感，让使用者更好地专注于业务逻辑的开发。这正是tunkjs存在的价值及努力的方向。 状态管理已在现有架构概念中成为焦点，但它并不是视图层之外的全部。在很多项目应用中，我们经常会碰到一些不适用状态管理的场景，在单纯处理状态管理的骨架里并不能灵活处理这些场景，要不绕个圈拿数据，要不就把这一块数据的处理放在视图组件里实现。项目经过长时间的迭代，越发觉得常规的状态流方案存在着一些浪费成本的编码环节，既不能很好的专注于业务逻辑的开发，也提高了开发维护成本。因此我们调整了状态流模式，实现了一个框架自身存在感更低、状态变更也完全可预测的数据服务框架。 你需要面向数据逻辑对象来合理设计模块类，将数据处理逻辑集中到模块里实现，视图组件只关注内容展示和交互处理。这样的好处是减轻视图层的复杂度，调试排错时数据问题与交互问题更容易区分定位和处理。 在很多项目应用中，我们经常会碰到一些不适用状态管理的场景，在单纯处理状态管理的骨架里并不能灵活处理这些场景。另外，项目经过长时间的迭代，越发觉得常规的状态流方案存在着一些不必要的编码环节，一定程度上提高了开发维护成本。 tunkjs 应运而生！ var className='toc';"}}
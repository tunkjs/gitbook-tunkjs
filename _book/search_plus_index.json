{"./":{"url":"./","title":"介绍","keywords":"","body":" tunkjs基于传统数据流的基础上定义了逻辑分层解耦及灵活通信的模式，是一个具有状态管理功能的前端数据服务框架。 tunkjs使前端业务逻辑划分为数据处理逻辑与交互处理逻辑，这两种逻辑分别构成数据服务层及视图层，数据服务层的状态数据统一存储在一个Store的状态树，视图组件面向数据服务层进行通信。 tunk除了实现了常规状态数据流，也提供了基于action但绕过Store的传输方式，可满足不适用状态管理或性能要求较高的场景，有利于将逻辑处理从视图层剥离。 tunk通过限制数据服务模块对状态树的更新范围来避免状态变更的失控，只要合理抽象数据服务模块，无需向Store描述状态变更也可保证状态变更是可预测的。 tunk力图简化它的API及编码细节，使框架自身存在感更低、编码方式更自然，让使用者更专注于业务的实现，此外，用于绑定不同视图框架的组件（tunk-vue/tunk-react/tunk-wechat）API几乎一致，无需花太多时间掌握不同绑定组件的使用. 安装 安装tunkjs核心，压缩后不超过7kb npm install tunk -S 除了tunk一般你还需要安装视图框架绑定组件 搭配vue npm install tunk-vue -S 搭配react或react native npm install tunk-react -S 搭配微信小程序 npm install tunk-wechat -S 相关文档 20分钟快速上手 基本概念 数据流 tunk API module API tunk-react tunk-vue tunk-wechat 组件开发 middleware hooks store config 组件推荐 tunk-debug tunk-request tunk-loader 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-03-01 16:31:04 "},"doc/intro/20分钟快速上手.html":{"url":"doc/intro/20分钟快速上手.html","title":"20分钟快速上手","keywords":"","body":"20分钟快速上手教程 tunk旨在优化前端架构、提高开发体验、掰直学习曲线、降低web前端项目开发维护成本，为此做了一定的封装让其拥有必要的特性、减少特有的规则及编码细节、精简接口，入门只需要掌握几个方法的使用便可接手tunk架构项目的业务开发。 tunk架构下，你的前端代码一般会被分为两层：数据服务层与视图表现层，数据服务层由N个数据服务模块组成，视图层由仅仅负责数据展现与交互处理。视图组件面向数据服务层进行通信，包括发起服务模块的action执行，以及订阅状态更新。 接到一个业务需求你通常要做两件事，一个是根据业务需求和接口的数据逻辑设计模块类，另一件事是写视图组件。 场景：开发一个用户管理列表，列表中弹框查看用户详细信息 写个数据服务模块 import {create, action} from 'tunk' // 创建userAdmin服务模块 @create class userAdmin { constructor(){ // state属性仅用于在构造器中定义当前模块负责维护的状态字段 // 服务模块被创建后，Store状态树创建'userAdmin'节点，节点初始内容来自state // 下面仅定义list为【状态字段】 this.state = { list:[] } } // @action 定义一个请求用户列表数据的Action // 只有userAdmin模块的action可以更新'userAdmin'节点的状态 // 并且只能更新已存在的状态字段，即 list 字段 @action fetchList(param){ // request 是tunk-request组件提供的模块内置方法 const res = this.request(...); // 返回的结果可更新Store状态树 userAdmin 节点下的list字段，触发状态变更钩子 return {list: res.list}; } @action async getUserDetails(id){ const res = await this.request(...); // details没有定义为状态字段，action处理结果的details字段不会更新到Store中 // 发起的action执行可获得返回结果，如： // const details = await this.getUserDetails(id).details; return {details: res.data}; } someFunc(){ // 获取当前模块的状态 const state = this.getState(); } ... } 如果你的构建环境不支持修饰器和async/await，譬如微信小程序，你可以这样写一个模块 // 注意：这里首字母大写 import {Create, Action} from 'tunk' Create('userAdmin', { // 注意：构造器 采用constructor(){}的写法会导致意外出错 constructor: function(){ this.state = { list:[] }; }, fetchList: Action(function(param) { return this.request(...).then((res)=>{ return {list: res.list}; }); }); }, getUserDetails: Action(function(id){ return this.request(...).then((res)=>{ return {details: res.data}; }); }), someFunc(){ const state = this.getState(); } ... }); 下面开发个视图组件 tunk与视图框架配合工作，需要跟视图框架绑定的组件，如tunk-vue、tunk-react、tunk-wechat 这些绑定组件负责定义视图组件如何 触发Action 及如何 将新状态注入到视图组件。 下面你可以挑你要用到的视图框架的实例来阅读 Vue ... 查看用户信息 ... export default { // 状态订阅配置 state: { // list 是模块userAdmin定义的状态字段，可以被视图组件订阅 // 组件被初始化后this.list将被注入当前 userAdmin.list 的状态 list: 'userAdmin.list' }, // 代理action设置 actions:{ // 创建getDetails方法可调起模块的getUserDetails getDetails: 'userAdmin.getUserDetails', }, created(){ // 通过dispatch方式调起action this.dispatch('userAdmin.fetchList'); }, methods:{ async showUserDetails(id){ // 调用action代理方法，并获得action执行结果 const details = await this.getDetails(id).details; // 也可以通过dispatch调起action // const details = await this.dispatch('userAdmin.getUserDetails', id).details; } } } React import { connect } from 'tunk-react' @connect({ // 状态订阅配置 // list 是模块userAdmin定义的状态字段，可以被视图组件订阅 // 组件被初始化后this.list将被注入当前 userAdmin.list 的状态 list: 'userAdmin.list' }, {// 代理action设置 // 创建getDetails方法可调起模块的getUserDetails getDetails: 'userAdmin.getUserDetails' }) export default class UserAdmin extends Component { constructor() { // 通过dispatch方式调起action this.dispatch('userAdmin.fetchList'); } async showUserDetails(id) { // 调用action代理方法，并获得action执行结果 const details = await this.getDetails(id).details; // 也可以通过dispatch调起action // const details = await this.dispatch('userAdmin.getUserDetails', id).details; } render() { // 以prop的方式注入到当前组件 const { list } = this.props; return ( {list.map(item => ( ... 查看用户信息 ))} ... ) } } 微信小程序 import {Page} from 'tunk-wechat' Page({ // 状态订阅配置，Page隐藏状态下不会被注入状态 // onShow时会重新注入已订阅的且已变更的状态 state: { // list 是模块userAdmin定义的状态字段，可以被视图组件订阅 // 组件被初始化后this.list将被注入当前 userAdmin.list 的状态 list: 'userAdmin.list' }, // 代理action设置 actions:{ // 创建getDetails方法可调起模块的getUserDetails getDetails: 'userAdmin.getUserDetails' }, // list有新状态准备注入前调用 onBeforeStateChange(newState){ // state订阅的状态数据，会被注入到this.data中 const oldListState = this.data.list; // 返回结果可控制setData的内容 // 若没有定义onBeforeStateChange或没有返回Object内容，则默认注入newState return {list: newState.list.concat(oldListState)} }, onLoad(){ // 通过dispatch方式调起action this.dispatch('userAdmin.fetchList'); }, showUserDetails(id){ // 若action为同步函数，可直接获得结果，若为异步需在then方法中获得 // 调用action代理方法，并获得action执行结果 this.getDetails(id).then(data => { const details = data.details; ... }); // 也可以通过dispatch调起action // this.dispatch('userAdmin.getUserDetails', id).then(...); } } 视图组件与tunk数据服务层通信 A. 两种方式触发模块的Action 通过在设置action属性（vue/微信小程序）或connect（react）设置action注入配置，向视图组件注入Action代理方法，向视图组件注入Action代理方法 使用 this.dispatch('moduleName.actionName', [arg1, arg2, ...])，支持异步 B. 两种方式获得Action处理结果 被动注入：通过设置属性state，可订阅不同模块的状态 主动获取：dispatch方法调起action，支持返回action执行结果，支持异步 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-03-18 23:08:03 "},"doc/base/基本概念.html":{"url":"doc/base/基本概念.html","title":"基本概念","keywords":"","body":"1. tunk基本概念1.1. Store1.2. State1.3. Module(模块)1.4. Action1. tunk基本概念 1.1. Store 存储状态树数据，提供tunk内部读取和更新状态树数据的方法。 tunk默认使用的是内置的Store对象，你也可以使用自定义的Store对象来改变数据存储、读取方式 对常规业务开发是透明的，仅在扩展组件的开发中暴露store相关接口 开发自定义Store对象 1.2. State 读取自store的状态快照，修改state将不会影响到store存储的数据 在constructor内赋给this.state的对象字段作为定义该模块的状态字段，后续的状态维护将不会再创建新状态字段， 模块内部可通过this.state和this.getState()读取当前模块的state，向this.getState()传入参数，也可获得其他模块的state 使用tunk-vue 或 tunk-react的时候，state也会被注入到订阅了特定模块的state的视图组件 1.3. Module(模块) 负责定义初始化状态数据及维护这些数据的Action集合，是一个Store数据树子集数据的处理类的实例化对象。 通过@create或tunk.createModule()创建并实例化 constructor内定义的this.state的对象作为Store内同类名节点的初始数据 一个模块负责管理Store数据树的一个子集 1.4. Action 模块类中使用@action修饰的方法，唯一可触发Store状态变化的方式。 Action通过return返回的数据和dispatch方法传入的数据都会先经过 中间件 的处理，最后可能会触发State的变化 支持异步Action，避免过多函数嵌套 @action async fetchList(page, page_size){ const res = await this.request ... return {list: res.list, totalCount: res.total_count} } 在异步Action调起其他Action，可获得被调用Action return返回的结果，此时，store已经完成状态的更新 //异步Action @action async deleteUser(uid){ //可获得Action执行return的结果 const result1 = await this.check(uid); ... }, @action async check(uid){ return await this.request(...); } 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-03-18 23:01:54 "},"doc/base/数据流.html":{"url":"doc/base/数据流.html","title":"数据流","keywords":"","body":" 视图层触发交互事件 交互事件回调发起Action执行 执行Action Action返回的结果或dispatch的数据，进入中间件处理流程 满足一定条件进入到内置store中间件后，调起setStore钩子 setStore钩子执行Store对象提供的方法 store.setState 将定义为状态的字段数据存储到store，并返回action执行返回的所有数据 让视图框架跟tunk一起工作的组件（如tunk-vue）切入setStore钩子获得状态更新的通知 在切入setStore钩子的回调，获取到新状态并找到绑定了新状态相关字段的视图组件，将新状态数据逐一注入其中 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-12 14:58:04 "},"doc/base/tunk-api.html":{"url":"doc/base/tunk-api.html","title":"tunk API","keywords":"","body":"1. tunk API1.1. @create1.2. @action1.3. Create1.4. Action1.5. use1.6. config1. tunk API 1.1. @create @create([moduleName:String, options:Object]) create修饰器，用于重构模块类及生成模块实例 moduleName：由于UgligyJS会将类名压缩，因此没使用tunk-loader的话需要传入需要创建的模块名 options：为模块级别的配置，将覆盖全局配置中同名字段的配置 如仅查看某个action的相关debug log: tunk.config({debug:false}); // 在特定的模块create修饰器传入即可 @create({debug: true}) class someModule{ ... } 1.2. @action @action([options:Object]) action修饰器，用于定义一个方法为一个Action options：为action级别的配置，将覆盖模块配置中同名字段的配置 跟全局配置与模块配置的关系，相当于 Object.assign(globalConfig, moduleConfig, actionConfig) 如仅查看某个action的相关debug log: @action({debug: true}) 1.3. Create tunk.Create(moduleName:String, module:Object, [options:Object]) 若语法环境不支持修饰器的写法，tunk还提供了ES5写法 moduleName：模块名 module：模块对象，对象必须有constructor方法 options：模块配置，同@create(options) 作用一致 tunk.Create('userAdmin', { constructor: function userAdmin(){ this.state = { list:[] }; } }, {debug:true}); 1.4. Action tunk.Action(target:Function, [options:Object]) 跟tunk.Create配合使用，定义一个方法为Action target：需要被定义为Action的函数 options：action级别的配置，同@action(options) 作用一致 tunk.Create('userAdmin', { constructor: function userAdmin(){ this.state = { list:[] }; }, fetchList: tunk.Action(function(){ ... }, {debug: true}), }); 1.5. use tunk.use(plugins:Array) 使用tunk组件，了解tunk组件开发，可戳这里 tunk组件开发 import tunk from \"tunk\"; import tunkVue from \"tunk-vue\"; import tunkDebug from \"tunk-debug\"; tunk.use([tunkVue, tunkDebug]); 1.6. config tunk.config(configs:Object) tunk全局配置 // debug配置由debug组件提供支持，设为true可查看全局相关debug log tunk.config({debug:true}); 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-12 14:57:29 "},"doc/base/module-api.html":{"url":"doc/base/module-api.html","title":"module API","keywords":"","body":"1. module API1.1. constructor1.2. state1.3. getState1.4. dispatch1.5. mixin methods1. module API 1.1. constructor 构造器负责完成一些模块初始化操作，如状态字段的定义 constructor() { this.state = { .... }; .... do something } 1.2. state 定义状态树节点的数据 state属性只能在constructor内赋值，模块初始化之后会在Store状态树中生成与模块类名同名的节点，state被赋予的值作为该节点的内容 @create class userAdmin{ constructor() { this.state = { list:[], total: 0 }; } } /* 初始化后，store状态树生成节点 state tree { userAdmin: { list:[], // 状态字段list total: 0 // 状态字段total } ....其他节点 } */ state的值必须是一个Object对象，对象的字段和字段对应的初始值作为该模块定义的状态字段及字段初始值 模块实际不存储数据，读取的数据都来自状态树相应节点的状态快照 1.3. getState 获得当前模块对应状态树节点的状态快照 this.getState([statePath:string]); myMethodOfModule(){ // 不传参数读取的是当前模块的状态，读取数据就用到 this.getState(); this.getState(); // 获取模块名为'userAdmin'的模块字段名为'list'的状态 this.getState('userAdmin.list'); // 模块名为'userAdmin'的模块字段名为'list'的数据是一个数组，将读取这个数组第一个元素的id this.getState('userAdmin.list.0.id'); } 1.4. dispatch 负责从action或非aciton方法中将数据传入tunk进入到后续处理环节 this.dispatch([arg1, arg2, arg3...]); dispatch只起到一个传递数据的作用，传参格式由中间件决定，tunk内部内置一个中间件：Promise中间件。 Promise中间件 this.dispatch(new Promise((resolve)=>{resolve({stateName: value});})) 异步action也是通过Promise中间件实现的 promise中间件执行完，由于产生数据变更会将promise处理结果重新dispatch进入中间件处理 关于更多中间件的内容，请查看 组件开发-中间件 1.5. mixin methods 由组件提供的模块通用内置方法，详细请查看 tunk组件开发 - mixin 譬如，tunk-request 组件提供模块内置方法：request 模块的方法内可直接使用：this.request(...); 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-03-18 23:08:33 "},"doc/plugins/tunk-react.html":{"url":"doc/plugins/tunk-react.html","title":"tunk-react","keywords":"","body":"tunk-react tunk-react定义了react与tunk配合工作的方式： 触发Action 及 将新状态注入视图组件 安装 npm install tunk-react -S 引入 import tunk from 'tunk'; import tunkReact from 'tunk-react'; tunk.use([tunkReact, tunkDebug]); // 引入状态管理模块即可完成状态管理模块的初始化 //require('./userAdmin'); // 也可批量引入（通常我们都把模块js放到统一目录下，如：modules） var modules = require.context('./modules', true, /\\.js$/); modules.keys().forEach((item) => { modules(item); }); A. 如何调起模块的Action import { connect } from 'tunk-react' @connect({}, {// 代理action设置 // 创建getDetails方法可调起模块的getUserDetails getDetails: 'userAdmin.getUserDetails' // 若设置为 userAdmin: 'userAdmin' // 则将所有方法注入到userAdmin属性 // 通过 this.userAdmin.getUserDetails(...) 调用 }) export default class UserAdmin extends Component { constructor() { // 1、通过dispatch方式调起action this.dispatch('userAdmin.fetchList'); } async showUserDetails(id) { // 2、调用action代理方法 this.getDetails(id).details; } render() { const { list } = this.props; return ( {list.map(item => ( ... 查看用户信息 ))} ) } } 两种方式调起action 通过在connect设置action注入配置，向视图组件注入Action代理方法 使用tunk-react提供的 this.dispatch('moduleName.actionName', [arg1, arg2, ...])，支持返回action内执行return的内容，支持Promise B. 视图组件获得新状态 import { connect } from 'tunk-react' @connect({ // 1、状态订阅配置 // list 是模块userAdmin定义的状态字段，可以被视图组件订阅 // 组件被初始化后this.list将被作为prop注入当前 userAdmin.list 的状态 // 注入前触发 componentWillReceiveProps list: 'userAdmin.list' }) export default class UserAdmin extends Component { constructor() { // 通过dispatch方式调起action // action返回状态字段数据更新store状态树状态，从而注入到当前组件 this.dispatch('userAdmin.fetchList'); } async showUserDetails(id) { // 2、调用action代理方法，并获得action执行结果 const details = await this.getDetails(id).details; // 也可以通过dispatch调起action获得action执行结果 // const details = await this.dispatch('userAdmin.getUserDetails', id).details; } render() { // 以prop的方式注入到当前组件 const { list } = this.props; return ( {list.map(item => ( ... 查看用户信息 ))} ) } } 两种方式获得新状态 被动注入：通过给组件添加订阅状态属性state，设置要订阅的模块状态字段路径，该视图组件将会被动态注入相关的状态数据 主动获取：tunk-vue为vue组件提供的 dispatch方法，可获得action方法return的内容 更多tunk实例 github 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-06 23:36:07 "},"doc/plugins/tunk-vue.html":{"url":"doc/plugins/tunk-vue.html","title":"tunk-vue","keywords":"","body":"tunk-vue tunk-vue 顾名思义，是让tunk与vue可以一起工作的组件，负责定义视图层如何 触发Action 及如何 将新状态注入到视图组件。 安装 npm install tunk-vue -S 引入 import tunk from 'tunk' import tunkVue from 'tunk-vue' tunk.use([tunkVue]); // 引入状态管理模块即可完成状态管理模块的初始化 //require('./userAdmin'); // 也可批量引入（通常我们都把模块js放到统一目录下，如：modules） var modules = require.context('./modules', true, /\\.js$/); modules.keys().forEach((item) => { modules(item); }); A. 两种方式触发模块的Action 通过添加actions属性向视图组件注入Action代理方法 使用tunk-vue提供的 this.dispatch('moduleName.actionName', [arg1, arg2, ...])，支持返回action内执行return的内容，支持Promise 注意： $dispatch是vue内置的方法，不带 $ 的是tunk-vue提供的方法 ... 查看用户信息 ... export default { actions: { // 设置actions，注入action代理方法 getDetails: 'userAdmin.getUserDetails', // 若设置为 userAdmin: 'userAdmin' // 则将所有方法注入到userAdmin属性 // 通过 this.userAdmin.getUserDetails(...) 调用 }, created() { // 通过dispatch方式调起action this.dispatch('userAdmin.fetchList'); }, methods:{ async showUserDetails(id){ // 调用action代理方法 const details = await this.getDetails(id).details; } } } 通过state设置订阅的状态变更，会先触发 beforeStState 钩子，并传入新状态变更 用户可通过beforeStState控制新状态通过setData注入当前组件，beforeStState中return返回的对象将会代替newState注入到组件中 如用户未定义beforeStState或beforeStState未返回Object结果，将直接将新状态注入到组件 B. 两种方式获得Action处理结果 被动注入：通过给组件添加订阅状态属性state，设置要订阅的模块状态字段路径，该视图组件将会被动态注入相关的状态数据 主动获取：tunk-vue为vue组件提供的 dispatch方法，可获得action方法return的内容 ... 查看用户信息 ... export default { // 状态订阅配置 state: { // list 是userAdmin定义的状态字段 // 组件被初始化后this.list将被注入当前 userAdmin.list 的状态 list: 'userAdmin.list' }, created() { this.dispatch('userAdmin.fetchList'); } methods: { async showUserDetails(id) { // 主动获取用户详情 const details = await this.dispatch('userAdmin.getUserDetails', id).details; ... } } } 更多tunk实例 github 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-06 23:34:01 "},"doc/plugins/tunk-wechat.html":{"url":"doc/plugins/tunk-wechat.html","title":"tunk-wechat","keywords":"","body":"tunk-wechat tunk-wechat使tunk支持微信小程序，负责定义视图层如何 触发Action 及如何 将新状态注入到视图组件。 微信小程序整体代码风格跟vue有几分相似，我们可以将小程序提供的js-wxml-wxss代码结构看作一个视图组件，tunk担当数据服务层，tunk与微信小程序完美合体！ tunk灵活的通信机制可以有效避开状态管理的性能问题，为了提高tunk与小程序协作能力，我们也做了有针对性的优化。譬如，隐藏的页面不会被注入新状态，提供onBeforeStateChange钩子控制如何setData 针对小程序性能相关优化： 状态变更不会注入到隐藏Page，只会告诉Page有哪些订阅的状态发生变更，onShow的时候再读取发生变更的状态注入到Page 安装 npm install tunk-wechat -S 引入 import tunk from 'tunk' import tunkWechat, {App} from 'tunk-wechat' tunk.use([tunkWechat]); // 引入放在modules文件夹下面的countdown模块 require('modules/countdown'); App({ onLaunch: function () {} } API tunk-wechat内部封装了全局App、Page构建方法，同时提供同名的构建方法，使用方式也与小程序提供的App、Page一致 import {App, Page} from 'tunk-wechat' App 注册小程序 actions属性 支持actions属性的设置，注入action的代理方法 App({ actions:{ myFunc: 'myModule.myAction' }, onLaunch: function () { // 调用myModule模块的myAction代理方法 this.myFunc(); } } dispatch方法 支持使用dispatch调起模块的action App({ onLaunch: function () { // 调起myModule模块的myAction this.dispatch('myModule.myAction', arg1, arg2...); } } Page 注册页面 Page支持actions设置和dispatch方法，下面不再说明 state设置 Page({ state: { cd: 'countdown.count' } } Page执行后，会给data对象添加相应的字段，如上例的：cd字段，Page onload前或状态变更后，会将'countdown.count'对应状态数据，通过setData注入到cd字段 状态变更不会注入到隐藏的Page，只会记录该Page有哪些订阅的状态发生变更，onShow之后将会从数据服务层获得已订阅的、已变更的最新状态 onBeforeStateChange Page({ state: { cd: 'countdown.count' }, onBeforeStateChange(newState){ return {cd: newState.cd} } } 通过state设置订阅的状态变更，在setData前，会先触发 onBeforeStateChange 钩子，并传入新状态变更 用户可通过onBeforeStateChange控制新状态通过setData注入当前组件，onBeforeStateChange中return返回的对象将会代替newState执行setData注入到组件中 如用户未定义onBeforeStateChange或onBeforeStateChange未返回Object结果，将直接将新状态通过setData注入到组件 不建议把过多的逻辑放到onBeforeStateChange处理 dispatch 用于调起数据服务模块的action，可获得返回action内执行return的内容，支持Promise Page({ onLoad(){ this.dispatch('countdown.increase', arg1, arg2 ...); } } 与tunk数据服务层通信总结 A. 两种方式触发模块的Action 通过添加actions设置向视图组件注入Action代理方法，直接调用这些代理方法 使用tunk-wechat提供的 this.dispatch('moduleName.actionName', [arg1, arg2, ...]) B. 两种方式获得Action处理结果 被动注入：通过给组件添加订阅状态属性state，设置要订阅的模块状态字段路径，该视图组件将会被动态注入相关的状态数据 主动获取：tunk-wechat为小程序App、Page提供的 dispatch方法，可获得action方法return的内容 更多tunk实例 github 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-22 23:07:05 "},"doc/plugin-dev/":{"url":"doc/plugin-dev/","title":"组件开发","keywords":"","body":"1. 组件开发1. 组件开发 middleware hooks store config 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-12 14:49:22 "},"doc/plugin-dev/middleware.html":{"url":"doc/plugin-dev/middleware.html","title":"middleware","keywords":"","body":" 待更新... 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-04 23:03:39 "},"doc/plugin-dev/hooks.html":{"url":"doc/plugin-dev/hooks.html","title":"hooks","keywords":"","body":" 待更新... 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-04 23:04:32 "},"doc/plugin-dev/store.html":{"url":"doc/plugin-dev/store.html","title":"store","keywords":"","body":" 待更新... 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-04 23:02:55 "},"doc/plugin-dev/config.html":{"url":"doc/plugin-dev/config.html","title":"config","keywords":"","body":"粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-06 19:28:15 "},"doc/plugin-dev/mixin.html":{"url":"doc/plugin-dev/mixin.html","title":"mixin","keywords":"","body":"粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-12 15:04:24 "},"doc/plugins/":{"url":"doc/plugins/","title":"组件推荐","keywords":"","body":"1. 组件推荐 1. 组件推荐 tunk-debug tunk-request tunk-loader 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-12 14:50:40 "},"doc/plugins/tunk-debug.html":{"url":"doc/plugins/tunk-debug.html","title":"tunk-debug","keywords":"","body":"tunk-debug tunk开发的debug工具，设置了 debug:true 之后的动作执行，在console中会有相应详细信息输出 安装 npm install tunk-debug 引用 import tunkDebug from 'tunk-debug' tunk.use([tunkDebug]); 启用配置 debug:[true | false | Array] default: false // 1、全局配置debug，作用到所有模块和action tunk.config({debug:true}); // 2、针对模块配置，仅作用于该模块，及该模块的所有action @create({debug: true}) class demo { constructor(){ .... } // 3、针对ation配置，仅作用于该action @action({debug:false}) sayHi(){ ... } } 当debug为Array时，元素取值为hooks名，仅打出传入的hooks 本插件会在console打印出所有hooks名 tunk.config({debug: ['setState', 'getState']}); github 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-06 23:25:31 "},"doc/plugins/tunk-request.html":{"url":"doc/plugins/tunk-request.html","title":"tunk-request","keywords":"","body":"1. tunk-request1. tunk-request ajax请求工具插件，支持promise 安装 npm install tunk-request -S 引用 import tunkRequest from \"tunk-request\"; tunk.use([ tunkRequest({ onBeforeSend: () => {}, onComplite: dataString => (dataString), onSuccess: (res, xhr, setting) => {}, onError: (error, xhr, setting) => {} }) ]); ### Methods ````javascript import {create, action} from 'tunk'; @create export default class app { constructor(){ this.state = { hello: 'tunk-request' }; this.request(Options) // 便捷方法，仅支持 url, data, success, error, dataType 参数，且参数顺序可不固定 // 第一个字符串 视为 url， 第一个function 视为 success this.request.get( url, data, success, error, dataType ) this.request.post( url, data, success, error, dataType ) this.request.getJson( url, data, success, error ) this.request.jsonp( url, data, success, error ) } @action async getData(){ const res = await this.request.get( url, data, success, error, dataType ) return {hello: res.tunk.request} } } Options // Default type of request type: 'GET', // html json script xml text dataType: '', // Callback that is executed before request beforeSend: empty, // Callback that is executed if the request succeeds success: empty, // Callback that is executed the the server drops error error: empty, // Callback that is executed on request complete (both: error and success) complete: empty, // Whether to trigger \"global\" Ajax events global: true, // Transport xhr: function () { return new window.XMLHttpRequest() }, // MIME types mapping // IIS returns Javascript as \"application/x-javascript\" accepts: { script: 'text/javascript, application/javascript, application/x-javascript', json: jsonType, xml: 'application/xml, text/xml', html: htmlType, text: 'text/plain' }, // Whether the request is to another domain crossDomain: false, // Default timeout timeout: 0, // Whether data should be serialized to string processData: true, // Whether the browser should be allowed to cache GET responses cache: true, //Used to handle the raw response data of XMLHttpRequest. //This is a pre-filtering function to sanitize the response. //The sanitized response should be returned dataFilter: empty github 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-06 23:07:18 "},"doc/plugins/tunk-loader.html":{"url":"doc/plugins/tunk-loader.html","title":"tunk-loader","keywords":"","body":"tunk-loader webpack loader，用于处理使用修饰器时tunk模块被打包压缩时模块类名被压缩的尴尬 安装 npm install tunk-react -S 配置 { test: /\\.js$/, loader: ['babel-loader', 'tunk-loader'], exclude: /(node_modules)/ } github 粤ICP备18005283号 | Copyright © tunkjs.com 2018 all right reserved，powered by Gitbook上次更新： 2018-01-06 23:09:01 "}}